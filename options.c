#include"options.h"
#include"players_turns.h"
#include"v_do_check.h"
#include"input&output.h"
#include"save.h"

int computer_moves = 0  ;
int num_of_undo_done = 0 ; 
struct store_for_undo all_inputs[60] ;

int undo(){
    struct store_for_undo last_move ;
    last_move = all_inputs[p1.num_of_moves+p2.num_of_moves-1] ;
    
    // removing lines
    if ( last_move.r1 == last_move.r2 ){
    h_lines[last_move.r1-1][min(last_move.c1,last_move.c2)-1] = 0 ;
    }
    else{
    v_lines[last_move.c1-1][min(last_move.r1,last_move.r2)-1] = 0 ;
    }
    // removing dot
    dots[last_move.r1-1][last_move.c1-1]-- ;
    dots[last_move.r2-1][last_move.c2-1]-- ;

    // correct taken dots if affected by this move and remove the boxes if it has been generated by this move
    for(int i = 0 ; i < 2 ; ++i ){
        if( last_move.full_dots[i] == 1 ){
            tkn_dots -= 1 ;
        }
        if ( last_move.boxs_indx[i] != -1 ){
        boxes[last_move.boxs_indx[i]] = 0 ;
        }
    }
    //  edit the moves and the score 
    if ( last_move.turn == 0 ){
        p1.num_of_moves-- ;
        if ( last_move.num_of_boxes ){
            p1.score -= last_move.num_of_boxes ; 
        }
    }
    else{
        p2.num_of_moves-- ;
        if ( last_move.num_of_boxes ){
            p2.score -= last_move.num_of_boxes ;
        }
    }

    // printf("%d %d %d %d\n%d\n%d\n%d %d\n%d %d\n" , last_move.r1 , last_move.r2 
    // , last_move.c1 , last_move.c2 , last_move.turn , last_move.num_of_boxes ,
    // last_move.boxs_indx[0] , last_move.boxs_indx[1] ,
    // last_move.full_dots[0] , last_move.full_dots[1] ) ;

    return last_move.turn ;
}
int redo (){
    struct store_for_undo last_move ;
    last_move = all_inputs[p1.num_of_moves+p2.num_of_moves] ;

    // restoring lines 
    if ( last_move.r1 == last_move.r2 ){
    h_lines[last_move.r1-1][min(last_move.c1,last_move.c2)-1] = last_move.turn+1 ;
    }
    else{
    v_lines[last_move.c1-1][min(last_move.r1,last_move.r2)-1] = last_move.turn+1 ;
    }
    // restoring dots
    dots[last_move.r1-1][last_move.c1-1]++ ;
    dots[last_move.r2-1][last_move.c2-1]++ ;
    //  restoring taken dots and boxes 
    for(int i = 0 ; i < 2 ; ++i ){
        if( last_move.full_dots[i] == 1 ){
            tkn_dots += 1 ;
        }
        if ( last_move.boxs_indx[i] != -1 ){
        boxes[last_move.boxs_indx[i]] = last_move.turn+1 ;
        }
    }
    // restoring moves and score 
    if ( last_move.turn == 0 ){
        p1.num_of_moves++ ;
        if ( last_move.num_of_boxes ){
            p1.score += last_move.num_of_boxes ; 
        }
    }
    else{
        p2.num_of_moves++ ;
        if ( last_move.num_of_boxes ){
            p2.score += last_move.num_of_boxes ;
        }
    }
    if ( last_move.num_of_boxes ){
    return last_move.turn ;
    }
    else
        return last_move.turn ^= 1  ;
}

int undo_1_v_pc(){
    struct store_for_undo last_move ;
    last_move = all_inputs[p1.num_of_moves+p2.num_of_moves-1] ;
    int cnt = last_move.compu_move_this_point ;
    for( int i = 0 ; i <= cnt ; ++i ){
    
    last_move = all_inputs[p1.num_of_moves+p2.num_of_moves-1] ;
    
    // removing lines
    if ( last_move.r1 == last_move.r2 ){
    h_lines[last_move.r1-1][min(last_move.c1,last_move.c2)-1] = 0 ;
    }
    else{
    v_lines[last_move.c1-1][min(last_move.r1,last_move.r2)-1] = 0 ;
    }
    // removing dot
    dots[last_move.r1-1][last_move.c1-1]-- ;
    dots[last_move.r2-1][last_move.c2-1]-- ;

    // correct taken dots if affected by this move and remove the boxes if it has been generated by this move
    for(int i = 0 ; i < 2 ; ++i ){
        if( last_move.full_dots[i] == 1 ){
            tkn_dots -= 1 ;
        }
        if ( last_move.boxs_indx[i] != -1 ){
        boxes[last_move.boxs_indx[i]] = 0 ;
        }
    }
    //  edit the moves and the score 
    if ( last_move.turn == 0 ){
        p1.num_of_moves-- ;
        if ( last_move.num_of_boxes ){
            p1.score -= last_move.num_of_boxes ; 
        }
    }
    else{
        p2.num_of_moves-- ;
        if ( last_move.num_of_boxes ){
            p2.score -= last_move.num_of_boxes ;
        }
    }

    printf("%d %d %d %d\n%d\n%d\n%d %d\n%d %d\n%d\n" , last_move.r1 , last_move.r2 
    , last_move.c1 , last_move.c2 , last_move.turn , last_move.num_of_boxes ,
    last_move.boxs_indx[0] , last_move.boxs_indx[1] ,
    last_move.full_dots[0] , last_move.full_dots[1],
    last_move.compu_move_this_point ) ;
    }
    return last_move.turn ;
}

int redo_1_v_pc (){
    struct store_for_undo last_move ;
    last_move = all_inputs[p1.num_of_moves+p2.num_of_moves] ;
    // int cnt = last_move.compu_move_this_point ;

    // for( int i = 0 ; i <= cnt ; ++i ){
    // last_move = all_inputs[p1.num_of_moves+p2.num_of_moves] ;
    // restoring lines 
    if ( last_move.r1 == last_move.r2 ){
    h_lines[last_move.r1-1][min(last_move.c1,last_move.c2)-1] = last_move.turn+1 ;
    }
    else{
    v_lines[last_move.c1-1][min(last_move.r1,last_move.r2)-1] = last_move.turn+1 ;
    }
    // restoring dots
    dots[last_move.r1-1][last_move.c1-1]++ ;
    dots[last_move.r2-1][last_move.c2-1]++ ;
    //  restoring taken dots and boxes 
    for(int i = 0 ; i < 2 ; ++i ){
        if( last_move.full_dots[i] == 1 ){
            tkn_dots += 1 ;
        }
        if ( last_move.boxs_indx[i] != -1 ){
        boxes[last_move.boxs_indx[i]] = last_move.turn+1 ;
        }
    }
    // restoring moves and score 
    if ( last_move.turn == 0 ){
        p1.num_of_moves++ ;
        if ( last_move.num_of_boxes ){
            p1.score += last_move.num_of_boxes ; 
        }
    }
    else{
        p2.num_of_moves++ ;
        if ( last_move.num_of_boxes ){
            p2.score += last_move.num_of_boxes ;
        }
    }
    
    if ( last_move.num_of_boxes ){
    return last_move.turn ;
    }
    else
        return last_move.turn ^= 1  ;
}

int options_window(){
    if ( game_mode == 2 ){
    printf("1_undo\n2_redo\n3_save\n4_exit\n") ;int cho ;scanf("%d" , &cho );
    if ( cho == 1 ){
        num_of_undo_done++ ;
        return undo() ;
    }
    else if ( cho == 2 ){
        if(num_of_undo_done){
        num_of_undo_done-- ;
        return redo() ;
        }
        else{
        printf("can't do redo at this position!\nno previous undo!!\n") ;
        return turn ; 
        }
    }
    else if ( cho == 3 ){
        return save_game() ;
    }
    else if ( cho == 4 ){
        return -1 ;
    }
    else{
        printf("invalid input\n") ;
        return turn ;
    }
    }
    else if (game_mode == 1 ){
    printf("1_undo\n2_redo\n3_save\n4_exit\n") ;int cho ;scanf("%d" , &cho );
    if ( cho == 1 ){
        num_of_undo_done++ ;
        return undo_1_v_pc() ;
    }
    else if ( cho == 2 ){
        if(num_of_undo_done){
        num_of_undo_done-- ;
        return redo_1_v_pc() ;
        }
        else{
        printf("can't do redo at this position!\nno previous undo!!\n") ;
        return turn ; 
        }
    }
    else if ( cho == 3 ){
        return save_game() ;
    }
    else if ( cho == 4 ){
        return -1 ;
    }
    else{
        printf("invalid input\n") ;
        return turn ;
    }
    }
}